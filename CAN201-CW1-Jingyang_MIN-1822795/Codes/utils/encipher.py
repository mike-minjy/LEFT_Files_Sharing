from os.path import join
from Crypto.Random import get_random_bytes
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad, unpad
from Crypto.Cipher import PKCS1_OAEP
from Crypto.PublicKey import RSA
from Crypto import Hash
from Crypto.Hash import SHA256
from Crypto.Signature import PKCS1_v1_5
from utils.__init__ import temp_dir


def get_sym_encryption_key():
    """get an AES symmetric key.
    It will generate a random key with length of 16 bytes (128 bits)."""
    return get_random_bytes(16)


def sym_encrypt(data: bytes, key: bytes = None):
    """Apply the symmetric encryption to the data when invoking ths method.
    Notice: the symmetric encryption key could be generated by method get_sym_encryption_key(),
    and pass into this method."""
    if key is None:
        key = get_random_bytes(16)
        # Instantiate the encryption suite in CBC mode.
        cipher = AES.new(key, AES.MODE_CBC)
        # The content would be encrypted, and the 'pad' method is used to group and pad.
        encrypted_data = cipher.encrypt(pad(data, AES.block_size))
        # Return the combined data as the following format.
        return b''.join((key, cipher.iv, encrypted_data))  # iv (initialization vector)

    cipher = AES.new(key, AES.MODE_CBC)
    encrypted_data = cipher.encrypt(pad(data, AES.block_size))
    return b''.join((cipher.iv, encrypted_data))


def sym_decrypt(data, key: bytes = None):
    """Apply the symmetric decryption to the data when invoking ths method.
    Notice: the symmetric encryption key should be consistent with the key applied in
    sym_encrypt(data: bytes, key: bytes = None) if the key parameter is not None."""
    # key is 16 bytes long in this case and iv (initialization vector) must be 16 bytes long for CBC mode.
    if key is None:
        key = data[:AES.block_size]
        iv = data[AES.block_size:2 * AES.block_size]
        encrypted_data = data[2 * AES.block_size:]
    else:
        iv = data[:AES.block_size]
        encrypted_data = data[AES.block_size:]

    # Instantiate the encryption suite
    cipher = AES.new(key, AES.MODE_CBC, iv)
    # Decryption
    return unpad(cipher.decrypt(encrypted_data), AES.block_size)


def generate_key_peer(save_to_local: bool = False):
    """generate key peer with 2048 bits long"""
    key_peer = RSA.generate(2048)
    # obtain private key
    private_key = key_peer.export_key()
    # obtain public key
    public_key = key_peer.publickey().export_key()
    # if not store keys to local, it would be return back to caller.
    if not save_to_local:
        return public_key, private_key
    # store to local 'temp' folder
    with open(join(temp_dir, 'private_key.pem'), 'wb') as writer:
        writer.write(private_key)
    with open(join(temp_dir, 'public_key.pem'), 'wb') as writer:
        writer.write(public_key)


def asym_encrypt(data, public_key: bytes = None):
    """Apply the asymmetric encryption to the data when invoking ths method."""
    # if public_key is None, then read public key from 'public_key.pem' in 'temp' folder
    if public_key is None:
        public_key = RSA.import_key(open(join(temp_dir, 'public_key.pem')).read())
    else:
        public_key = RSA.import_key(public_key)
    # Instantiate the encryption suite
    cipher = PKCS1_OAEP.new(public_key)
    # Return encrypted data
    return cipher.encrypt(data)


def asym_decrypt(encrypted_data, private_key: bytes = None):
    """Apply the asymmetric decryption to the data when invoking ths method."""
    # if private_key is None, then read private key from 'private_key.pem' in 'temp' folder
    if private_key is None:
        private_key = RSA.import_key(open(join(temp_dir, 'private_key.pem')).read())
    else:
        private_key = RSA.import_key(private_key)
    # Instantiate the encryption suite
    cipher = PKCS1_OAEP.new(private_key)
    # Return decrypted data
    return cipher.decrypt(encrypted_data)


def sign_signature(data: bytes, private_key: bytes):
    # sign signature using private key
    signer_obj = PKCS1_v1_5.new(RSA.importKey(private_key))
    digest = Hash.SHA256.new(data)
    return signer_obj.sign(digest)


def verify_signature(signature: bytes, data: bytes, public_key: bytes):
    # verify signature using public key
    verifier = PKCS1_v1_5.new(RSA.importKey(public_key))
    digest = Hash.SHA256.new(data)
    verifier.verify(digest, signature)
